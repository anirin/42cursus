#include <vector>
#include <iostream>
#include <cstdlib>
#include <ctime>


int d_jacob[] = {0,2,2,6,10,22,42,86,170,342,682,1366,2730,5462,10922,21846,43690,87382,174762,349526,699050,1398102,2796202,5592406,11184810};
int node_num[] = {0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262143,524287,1048575,2097151,4194303,8388607,16777215};

// indexに挿入する関数
void insertPart(std::vector<int> &array, int value, int index)
{
	std::vector<int> new_array;

	if (index == -1) {
		new_array.push_back(value);
	}
	for (int i = 0; i < array.size(); i++) {
		if (i == index) {
			new_array.push_back(value);
		}
		new_array.push_back(array[i]);
	}
	if (index == array.size()) {
		new_array.push_back(value);
	}

	array.clear();
	array = new_array;
}

// ソート済みの配列 に 値を２分探索して　挿入すべき index を取得
int binarySearch(std::vector<int> array, int start_index, int end_index, int size, int value) {
	int center_index;
	center_index = size / 2 + start_index;

	if (array[center_index] == value) {
		return center_index;
	}
	else if (array[center_index] < value)
	{
		if (center_index == end_index)
			return center_index + 1;
		return binarySearch(array, center_index + 1, end_index, end_index - center_index, value);
	}
	else // array[center_index] > value
	{
		if (center_index == start_index)
			return center_index; // -1が発生する可能性がある
		return binarySearch(array, start_index, center_index - 1, center_index - start_index, value);
	}
}

void removeElement(std::vector<int> &array, int value) // index にした方が効率がいい mem copyした方が効率がいいと思う
{
	int count = 0;
	std::vector<int> new_array;

	// 重複の場合にうまくいかないので一回だけ削除する
	for (int i = 0; i < array.size(); i++) {
		if (array[i] == value) {
			count++;
			if (count == 1) {
				continue;
			}
			new_array.push_back(array[i]);
		} else {
			new_array.push_back(array[i]);
		}
	}

	array.clear();
	array = new_array;
}

void mergePart(std::vector<int> &b_array, std::vector<int> s_array) // big, small array 共にソート済みの状態にして利用する
{
	if (s_array.size() == 0)
		return;
	insertPart(b_array, s_array[0], 0); //先頭に追加 node_num[0] = 1 -> node_num[1] = 3 になる
	removeElement(s_array, s_array[0]);

	int count = 0;

	for (;;)
	{
		if (s_array.size() == 0) // 全て格納が完了している状態
			break;

		// init
		int end;
		int insert_size;

		if (node_num[count + 4] < b_array.size())
			end = node_num[count + 4] - 1; // 0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023 ... つまり [4] 7 から始まる
		else
			end = b_array.size() - 1;

		if (d_jacob[count + 1] < s_array.size())
			insert_size = d_jacob[count + 1]; // 0, 2, 2, 6, 10, 22, 42, 86, 170, 342 ... つまり [1] 2 から始まる
		else
			insert_size = s_array.size();


		for (int i = 0; i < insert_size; i++)
		{
			if (s_array.size() == 0) // 全て格納が完了している状態
				break;

			// init
			int value;
			int target; // ok

			value = s_array[(insert_size - i) - 1];
			target = binarySearch(b_array, 0, end, end + 1, value);
			removeElement(s_array, value);
			insertPart(b_array, value, target);
		}

		count++;
	}
}

struct Layer
{
	std::vector<std::pair<int, int> > pairs; // index
	int rest;
	bool hasRest;
};

std::vector<int> makeBigArray(std::vector<std::pair<int, int> > pairs)
{
	std::vector<int> big_array;

	for (int i = 0; i < pairs.size(); i++)
	{
		big_array.push_back(pairs[i].first);
	}

	return big_array;
}

void makeLayer(std::vector<int> &array, std::vector<Layer> &Layers) // 分割できなくなるまで分割して保存する layerの要素数が1になるまで 注意：初期状態でsize1の場合は何もしない
{
	Layer layer;
	int size = array.size();
	layer.hasRest = false;

	if (size == 1)
	{
		return;
	}

	int i = 0;
	while (1)
	{
		if (size == i)
			break;

		if (i + 1 == size)
		{
			layer.rest = array[i];
			layer.hasRest = true;
			break;
		}

		int big = array[i];
		int small = array[i + 1];
		if (array[i] < array[i + 1])
		{
			big = array[i + 1];
			small = array[i];
		}
		layer.pairs.push_back(std::make_pair(big, small));

		i += 2;
	}
	Layers.push_back(layer);

	std::vector<int> big_array = makeBigArray(layer.pairs);
	makeLayer(big_array, Layers);
}

bool isSorted(std::vector<int>::iterator begin, std::vector<int>::iterator end)
{
	for (std::vector<int>::iterator it = begin; it != end - 1; it++) {
		if (*it > *(it + 1)) {
			return false;
		}
	}
	return true;
}

void printLayer(std::vector<Layer> Layers)
{
	for (int i = 0; i < Layers.size(); i++)
	{
		std::cout << " ======== Layer: " << i << std::endl;
		for (int j = 0; j < Layers[i].pairs.size(); j++)
		{
			std::cout << "big: " << Layers[i].pairs[j].first << " small: " << Layers[i].pairs[j].second << std::endl;
		}
		if (Layers[i].hasRest)
			std::cout << "rest: " << Layers[i].rest << std::endl;
		std::cout << std::endl;
	}
}

std::vector<int> sortSmallArray(Layer layer, std::vector<int> sorted_b_array)
{
	std::vector<int> new_array;

	for (std::vector<int> ::iterator it = sorted_b_array.begin(); it != sorted_b_array.end(); it++)
	{
		for (int i = 0; i < layer.pairs.size(); i++) // 重複処理において、pairを決定することができない
		{
			if (layer.pairs[i].first == *it)
			{
				new_array.push_back(layer.pairs[i].second);
			}
		}
	}
	if (layer.hasRest)
	{
		new_array.push_back(layer.rest);
	}

	return new_array;
}

void sort(std::vector<Layer> &Layers, int layer_index, std::vector<int> &sorted_b_array)
{
	if (layer_index == -1)
		return;

	if (sorted_b_array.size() == 0)
	{
		sorted_b_array.push_back(Layers[layer_index].pairs[0].first);
	}

		std::cout << "before_array: " << " =========== index: " << layer_index << std::endl;
		for (int i = 0; i < sorted_b_array.size(); i++)
			std::cout << sorted_b_array[i] << " ";
		std::cout << std::endl;

	Layer layer = Layers[layer_index];
	std::vector<int> sorted_s_array = sortSmallArray(layer, sorted_b_array);
	mergePart(sorted_b_array, sorted_s_array);

		std::cout << "small_array: " << std::endl;
		for (int i = 0; i < sorted_s_array.size(); i++)
			std::cout << sorted_s_array[i] << " ";
		std::cout << std::endl;

		std::cout << "after_array: " << std::endl;
		for (int i = 0; i < sorted_b_array.size(); i++)
			std::cout << sorted_b_array[i] << " ";
		std::cout << std::endl << std::endl;

	sort(Layers, layer_index - 1, sorted_b_array);
}

std::vector<int> randArray(int size)
{
	std::vector<int> array;

	std::srand(std::time(nullptr));
	for (int i = 0; i < size; i++)
	{
		array.push_back(rand() % 2);
	}

	return array;
}

int main()
{
	std::vector<Layer> Layers;
	std::vector<int> sorted_array;
	std::vector<int> array = randArray(10);

		for (int i = 0; i < array.size(); i++)
			std::cout << array[i] << " ";
		std::cout << std::endl << std::endl;

	makeLayer(array, Layers);

		printLayer(Layers);
		std::cout << std::endl;
		std::cout << " ============= Sorted Array =============" << std::endl;

	sort(Layers, Layers.size() - 1, sorted_array);

		std::cout << std::endl;
		for (int i = 0; i < sorted_array.size(); i++)
			std::cout << sorted_array[i] << " ";
		std::cout << std::endl;
		isSorted(sorted_array.begin(), sorted_array.end()) ? std::cout << "Sorted" << std::endl : std::cout << "Not Sorted" << std::endl;

	return 0;
}
